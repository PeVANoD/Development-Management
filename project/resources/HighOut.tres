[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://dpba1sbhm233x"]

[sub_resource type="Shader" id="Shader_jlu4r"]
code = "shader_type canvas_item;

// Outline shader variables
uniform vec4 outline_color : source_color = vec4(1.0);
uniform float outline_width : hint_range(0, 10) = 0;
uniform int pattern : hint_range(0, 2) = 0; // diamond, circle, square
uniform bool inside = true;
uniform bool add_margins = true; // only useful when inside is false

// Highlight shader variables
uniform vec4 highlight_color : source_color = vec4(1.0, 1.0, 1.0, 1.0);
uniform float size_effect : hint_range(0.0, 1.0) = 0.1;
uniform float highlight_speed : hint_range(-5.0, 5.0) = 1.0;
uniform float highlight_strength : hint_range(0.0, 4.0) = 0.5;
uniform float frequency : hint_range(0.1, 10.0) = 1.0; // Controls how often highlights appear
uniform float angle : hint_range(0.0, 360.0) = 0.0; // Angle in degrees for the highlight direction

void vertex() {
    if (add_margins) {
        VERTEX += (UV * 2.0 - 1.0) * outline_width;
    }
}

bool hasContraryNeighbour(vec2 uv, vec2 texture_pixel_size, sampler2D texture) {
    for (float i = -ceil(outline_width); i <= ceil(outline_width); i++) {
        float x = abs(i) > outline_width ? outline_width * sign(i) : i;
        float offset;

        if (pattern == 0) {
            offset = outline_width - abs(x);
        } else if (pattern == 1) {
            offset = floor(sqrt(pow(outline_width + 0.5, 2) - x * x));
        } else if (pattern == 2) {
            offset = outline_width;
        }

        for (float j = -ceil(offset); j <= ceil(offset); j++) {
            float y = abs(j) > offset ? offset * sign(j) : j;
            vec2 xy = uv + texture_pixel_size * vec2(x, y);

            if ((xy != clamp(xy, vec2(0.0), vec2(1.0)) || texture(texture, xy).a <= 0.0) == inside) {
                return true;
            }
        }
    }

    return false;
}

void fragment() {
    vec2 uv = UV;
    vec4 original_color = texture(TEXTURE, uv);

    // Сохраняем исходный modulate цвет
    vec4 modulate_color = COLOR;

    if (add_margins) {
        vec2 texture_pixel_size = vec2(1.0) / (vec2(1.0) / TEXTURE_PIXEL_SIZE + vec2(outline_width * 2.0));
        uv = (uv - texture_pixel_size * outline_width) * TEXTURE_PIXEL_SIZE / texture_pixel_size;

        if (uv != clamp(uv, vec2(0.0), vec2(1.0))) {
            COLOR.a = 0.0;
        } else {
            original_color = texture(TEXTURE, uv);
        }
    }

    // Применяем outline эффект
    vec4 final_color = original_color;

    // Проверяем, нужно ли применять outline
    bool should_apply_outline = false;

    if (inside) {
        // Для внутреннего outline: применяем если текущий пиксель непрозрачный И есть прозрачные соседи
        if (original_color.a > 0.0 && hasContraryNeighbour(uv, TEXTURE_PIXEL_SIZE, TEXTURE)) {
            should_apply_outline = true;
        }
    } else {
        // Для внешнего outline: применяем если текущий пиксель прозрачный И есть непрозрачные соседи
        if (original_color.a <= 0.0 && hasContraryNeighbour(uv, TEXTURE_PIXEL_SIZE, TEXTURE)) {
            should_apply_outline = true;
        }
    }

    if (should_apply_outline) {
        if (inside) {
            final_color.rgb = mix(original_color.rgb, outline_color.rgb, outline_color.a);
            final_color.a = original_color.a; // Сохраняем оригинальную альфу для внутреннего outline
        } else {
            final_color.rgb = outline_color.rgb;
            final_color.a = outline_color.a;
        }
    }

    // Применяем highlight эффект
    float time = TIME * highlight_speed;
    float current_time = fract(-time * frequency);
    current_time = mix(0.0 - size_effect, 1.0 + size_effect, current_time);

    // Convert angle to radians and calculate direction vector
    float angle_rad = radians(angle);
    vec2 direction = vec2(cos(angle_rad), sin(angle_rad));

    // Calculate position value along the direction vector
    float position_value = dot(uv - vec2(0.5), direction) + 0.5;

    float effect_lower_bound = current_time - size_effect;
    float effect_upper_bound = current_time + size_effect;

    float effect_distance = smoothstep(effect_lower_bound, current_time, position_value) -
                          smoothstep(current_time, effect_upper_bound, position_value);

    // Apply highlight effect
    if (final_color.a > 0.0) {
        vec3 highlight = highlight_color.rgb * highlight_color.a;
        final_color.rgb = mix(final_color.rgb, highlight, effect_distance * highlight_strength);
    }

    // В конце применяем modulate цвет ко всему результату
    COLOR = final_color * modulate_color;
}"

[resource]
shader = SubResource("Shader_jlu4r")
shader_parameter/outline_color = Color(1, 1, 1, 0.784314)
shader_parameter/outline_width = 0.0
shader_parameter/pattern = 2
shader_parameter/inside = true
shader_parameter/add_margins = true
shader_parameter/highlight_color = Color(1, 1, 1, 0.392157)
shader_parameter/size_effect = 1.0
shader_parameter/highlight_speed = -0.6
shader_parameter/highlight_strength = 0.6
shader_parameter/frequency = 0.7
shader_parameter/angle = 30.0
